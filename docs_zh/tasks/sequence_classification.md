# 文本分类

[[在 Colab 打开]]

[YouTube 视频](https://www.youtube.com/embed/leNG9fN9FQU)

文本分类是一种常见的自然语言处理任务，它将标签或类别分配给文本。一些最大的公司将文本分类应用于各种实际应用中。最流行的文本分类形式之一是情感分析，它将标签（例如：🙂积极、🙁消极或😐中性）分配给一段文本。

这个指南将向你展示如何：

1. 在 [IMDb](https://huggingface.co/datasets/imdb) 数据集上微调 [DistilBERT](https://huggingface.co/distilbert-base-uncased)，以确定一篇电影评论是积极的还是消极的。
2. 使用你微调的模型进行推断。

<Tip>
在本教程中演示的任务受以下模型架构的支持：

[ALBERT](../model_doc/albert)、[BART](../model_doc/bart)、[BERT](../model_doc/bert)、[BigBird](../model_doc/big_bird)、[BigBird-Pegasus](../model_doc/bigbird_pegasus)、[BioGpt](../model_doc/biogpt)、[BLOOM](../model_doc/bloom)、[CamemBERT](../model_doc/camembert)、[CANINE](../model_doc/canine)、[CodeLlama](../model_doc/code_llama)、[ConvBERT](../model_doc/convbert)、[CTRL](../model_doc/ctrl)、[Data2VecText](../model_doc/data2vec-text)、[DeBERTa](../model_doc/deberta)、[DeBERTa-v2](../model_doc/deberta-v2)、[DistilBERT](../model_doc/distilbert)、[ELECTRA](../model_doc/electra)、[ERNIE](../model_doc/ernie)、[ErnieM](../model_doc/ernie_m)、[ESM](../model_doc/esm)、[Falcon](../model_doc/falcon)、[FlauBERT](../model_doc/flaubert)、[FNet](../model_doc/fnet)、[Funnel Transformer](../model_doc/funnel)、[GPT-Sw3](../model_doc/gpt-sw3)、[OpenAI GPT-2](../model_doc/gpt2)、[GPTBigCode](../model_doc/gpt_bigcode)、[GPT Neo](../model_doc/gpt_neo)、[GPT NeoX](../model_doc/gpt_neox)、[GPT-J](../model_doc/gptj)、[I-BERT](../model_doc/ibert)、[LayoutLM](../model_doc/layoutlm)、[LayoutLMv2](../model_doc/layoutlmv2)、[LayoutLMv3](../model_doc/layoutlmv3)、[LED](../model_doc/led)、[LiLT](../model_doc/lilt)、[LLaMA](../model_doc/llama)、[Longformer](../model_doc/longformer)、[LUKE](../model_doc/luke)、[MarkupLM](../model_doc/markuplm)、[mBART](../model_doc/mbart)、[MEGA](../model_doc/mega)、[Megatron-BERT](../model_doc/megatron-bert)、[MobileBERT](../model_doc/mobilebert)、[MPNet](../model_doc/mpnet)、[MPT](../model_doc/mpt)、[MRA](../model_doc/mra)、[MT5](../model_doc/mt5)、[MVP](../model_doc/mvp)、[Nezha](../model_doc/nezha)、[Nyströmformer](../model_doc/nystromformer)、[OpenLlama](../model_doc/open-llama)、[OpenAI GPT](../model_doc/openai-gpt)、[OPT](../model_doc/opt)、[Perceiver](../model_doc/perceiver)、[Persimmon](../model_doc/persimmon)、[PLBart](../model_doc/plbart)、[QDQBert](../model_doc/qdqbert)、[Reformer](../model_doc/reformer)、[RemBERT](../model_doc/rembert)、[RoBERTa](../model_doc/roberta)、[RoBERTa-PreLayerNorm](../model_doc/roberta-prelayernorm)、[RoCBert](../model_doc/roc_bert)、[RoFormer](../model_doc/roformer)、[SqueezeBERT](../model_doc/squeezebert)、[T5](../model_doc/t5)、[TAPAS](../model_doc/tapas)、[Transformer-XL](../model_doc/transfo-xl)、[UMT5](../model_doc/umt5)、[XLM](../model_doc/xlm)、[XLM-RoBERTa](../model_doc/xlm-roberta)、[XLM-RoBERTa-XL](../model_doc/xlm-roberta-xl)、[XLNet](../model_doc/xlnet)、[X-MOD](../model_doc/xmod)、[YOSO](../model_doc/yoso)

<!--Generated by `make fix-copies`, do not modify manually.-->

</Tip>

在开始之前，请确保你已安装所有必要的库：

```bash
pip install transformers datasets evaluate
```

我们鼓励你登录到你的 Hugging Face 账户，以便你可以上传和分享模型。在提示时输入你的令牌登录：

```python
>>> from huggingface_hub import notebook_login

>>> notebook_login()
```

## 加载 IMDb 数据集

首先，从 🤗 Datasets 库中加载 IMDb 数据集：

```python
>>> from datasets import load_dataset

>>> imdb = load_dataset("imdb")
```

然后查看一个示例：

```python
>>> imdb["test"][0]
{
    "label": 0,
    "text": "I love sci-fi and am willing to put up with a lot. Sci-fi movies/TV are usually underfunded, under-appreciated and misunderstood. I tried to like this, I really did, but it is to good TV sci-fi as Babylon 5 is to Star Trek (the original). Silly prosthetics, cheap cardboard sets, stilted dialogues, CG that doesn't match the background, and painfully one-dimensional characters cannot be overcome with a 'sci-fi' setting. (I'm sure there are those of you out there who think Babylon 5 is good sci-fi TV. It's not. It's clichéd and uninspiring.) While US viewers might like emotion and character development, sci-fi is a genre that does not take itself seriously (cf. Star Trek). It may treat important issues, yet not as a serious philosophy. It's really difficult to care about the characters here as they are not simply foolish, just missing a spark of life. Their actions and reactions are wooden and predictable, often painful to watch. The makers of Earth KNOW it's rubbish as they have to always say \"Gene Roddenberry's Earth...\" otherwise people would not continue watching. Roddenberry's ashes must be turning in their orbit as this dull, cheap, poorly edited (watching it without advert breaks really brings this home) trudging Trabant of a show lumbers into space. Spoiler. So, kill off a main character. And then bring him back as another actor. Jeeez! Dallas all over again.",
}
```

此数据集有两个字段：

- `text`：电影评论文本。
- `label`：取值为 `0` 表示消极评论，取值为 `1` 表示积极评论。

## 预处理

下一步是加载 DistilBERT 的 tokenizer 来预处理 `text` 字段：

```python
>>> from transformers import AutoTokenizer

>>> tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")
```

创建一个预处理函数来对 `text` 进行分词和截断，以使其不超过 DistilBERT 的最大输入长度：

```python
>>> def preprocess_function(examples):
...     return tokenizer(examples["text"], truncation=True)
```

使用 🤗 Datasets [`~datasets.Dataset.map`] 函数对整个数据集应用预处理函数，通过将 `batched=True` 设置为一次处理数据集中的多个元素，可以加快处理速度：

```python
tokenized_imdb = imdb.map(preprocess_function, batched=True)
```

现在使用 [`DataCollatorWithPadding`] 创建一个示例的批处理。在 collation 过程中，将句子动态填充为一批中最长长度，而不是将整个数据集填充到最大长度。

<frameworkcontent>
<pt>
```python
>>> from transformers import DataCollatorWithPadding

>>> data_collator = DataCollatorWithPadding(tokenizer=tokenizer)
```
</pt>
<tf>
```python
>>> from transformers import DataCollatorWithPadding

>>> data_collator = DataCollatorWithPadding(tokenizer=tokenizer, return_tensors="tf")
```
</tf>
</frameworkcontent>

## 评估

在训练过程中包含一个评估指标通常对评估模型的性能很有帮助。你可以使用 🤗 [Evaluate](https://huggingface.co/docs/evaluate/index) 库快速加载一个评估方法。对于这个任务，加载 [accuracy](https://huggingface.co/spaces/evaluate-metric/accuracy) 指标（请参阅 🤗 Evaluate [快速入门](https://huggingface.co/docs/evaluate/a_quick_tour) 以了解有关如何加载和计算指标的更多信息）：

```python
>>> import evaluate

>>> accuracy = evaluate.load("accuracy")
```

然后创建一个函数，将模型的预测结果和标签传递给 [`~evaluate.EvaluationModule.compute`] 来计算准确率：

```python
>>> import numpy as np


>>> def compute_metrics(eval_pred):
...     predictions, labels = eval_pred
...     predictions = np.argmax(predictions, axis=1)
...     return accuracy.compute(predictions=predictions, references=labels)
```

现在你的 `compute_metrics` 函数已准备就绪，在设置训练时将返回它。

## 训练

在开始训练模型之前，使用 `id2label` 和 `label2id` 创建一个预期 id 到标签的映射：

```python
>>> id2label = {0: "NEGATIVE", 1: "POSITIVE"}
>>> label2id = {"NEGATIVE": 0, "POSITIVE": 1}
```

<frameworkcontent>
<pt>
<Tip>

如果你还不熟悉使用 [`Trainer`] 对模型进行微调，请查看[此处](../training.md#train-with-pytorch-trainer)的基本教程！

</Tip>

现在你已经准备好开始训练模型了！使用 [`AutoModelForSequenceClassification`] 加载 DistilBERT 并指定预期的标签数和标签映射：

```python
>>> from transformers import AutoModelForSequenceClassification, TrainingArguments, Trainer

>>> model = AutoModelForSequenceClassification.from_pretrained(
...     "distilbert-base-uncased", num_labels=2, id2label=id2label, label2id=label2id
... )
```

到这一步，只剩下三个步骤：

1. 在 [`TrainingArguments`] 中定义你的训练超参数。唯一必需的参数是 `output_dir`，用于指定保存模型的位置。通过设置 `push_to_hub=True`，你将把这个模型推送到 Hub（你需要登录到 Hugging Face 才能上传模型）。在每个 epoch 结束时，[`Trainer`] 将评估准确率并保存训练检查点。
2. 将训练参数与模型、数据集、tokenizer、数据处理器和 `compute_metrics` 函数一起传递给 [`Trainer`]。
3. 调用 [`~Trainer.train`] 来微调模型。

```python
>>> training_args = TrainingArguments(
...     output_dir="my_awesome_model",
...     learning_rate=2e-5,
...     per_device_train_batch_size=16,
...     per_device_eval_batch_size=16,
...     num_train_epochs=2,
...     weight_decay=0.01,
...     evaluation_strategy="epoch",
...     save_strategy="epoch",
...     load_best_model_at_end=True,
...     push_to_hub=True,
... )

>>> trainer = Trainer(
...     model=model,
...     args=training_args,
...     train_dataset=tokenized_imdb["train"],
...     eval_dataset=tokenized_imdb["test"],
...     tokenizer=tokenizer,
...     data_collator=data_collator,
...     compute_metrics=compute_metrics,
... )

>>> trainer.train()
```

<Tip>

[`Trainer`] 默认使用动态填充，所以当你将 `tokenizer` 传递给它时，默认会应用该机制。在此示例中，不需要显式地指定数据处理器。

</Tip>

训练完成后，使用 [`~transformers.Trainer.push_to_hub`] 方法将你的模型共享到 Hub，以供所有人使用：

```python
>>> trainer.push_to_hub()
```
</pt>
<tf>
<Tip>

如果你还不熟悉使用 Keras 对模型进行微调，请查看[此处](../training.md#train-a-tensorflow-model-with-keras)的基本教程！

</Tip>
要在 TensorFlow 中微调模型，请首先设置优化器函数、学习率计划和一些训练超参数：

```python
>>> from transformers import create_optimizer
>>> import tensorflow as tf

>>> batch_size = 16
>>> num_epochs = 5
>>> batches_per_epoch = len(tokenized_imdb["train"]) // batch_size
>>> total_train_steps = int(batches_per_epoch * num_epochs)
>>> optimizer, schedule = create_optimizer(init_lr=2e-5, num_warmup_steps=0, num_train_steps=total_train_steps)
```

然后，你可以加载 [`TFAutoModelForSequenceClassification`] 的 DistilBERT 和预期的标签数以及标签映射：

```python
>>> from transformers import TFAutoModelForSequenceClassification

>>> model = TFAutoModelForSequenceClassification.from_pretrained(
...     "distilbert-base-uncased", num_labels=2, id2label=id2label, label2id=label2id
... )
```

使用 [`~transformers.TFPreTrainedModel.prepare_tf_dataset`] 将数据集转换为 `tf.data.Dataset` 格式：

```python
>>> tf_train_set = model.prepare_tf_dataset(
...     tokenized_imdb["train"],
...     shuffle=True,
...     batch_size=16,
...     collate_fn=data_collator,
... )

>>> tf_validation_set = model.prepare_tf_dataset(
...     tokenized_imdb["test"],
...     shuffle=False,
...     batch_size=16,
...     collate_fn=data_collator,
... )
```

使用 [`compile`](https://keras.io/api/models/model_training_apis/#compile-method) 配置模型进行训练。请注意，Transformer 模型都有一个与任务相关的默认损失函数，所以除非你希望使用自定义的损失函数，否则不需要指定损失函数：

```python
>>> import tensorflow as tf

>>> model.compile(optimizer=optimizer)  # 没有损失参数！
```

在你开始训练之前，设置好最后两个事项，即从预测结果中计算准确率，并提供一种将你的模型推送到 Hub 的方式，这两个都是使用 [Keras 回调](../main_classes/keras_callbacks) 完成的。

将你的 `compute_metrics` 函数传递给 [`~transformers.KerasMetricCallback`]：

```python
>>> from transformers.keras_callbacks import KerasMetricCallback

>>> metric_callback = KerasMetricCallback(metric_fn=compute_metrics, eval_dataset=tf_validation_set)
```

在 [`~transformers.PushToHubCallback`] 中指定要将模型和 tokenizer 推送到的位置：

```python
>>> from transformers.keras_callbacks import PushToHubCallback

>>> push_to_hub_callback = PushToHubCallback(
...     output_dir="my_awesome_model",
...     tokenizer=tokenizer,
... )
```

将你的回调函数捆绑在一起：

```python
>>> callbacks = [metric_callback, push_to_hub_callback]
```

最后，你可以开始训练你的模型了！使用你的训练和验证数据集、epoch 数和回调函数来调用 [`fit`](https://keras.io/api/models/model_training_apis/#fit-method) 以进行微调：

```python
>>> model.fit(x=tf_train_set, validation_data=tf_validation_set, epochs=3, callbacks=callbacks)
```

训练完成后，你的模型会自动上传到 Hub，供所有人使用！
</tf>
</frameworkcontent>

<Tip>

有关如何为文本分类微调模型的更深入示例，请查看相应的
[PyTorch notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/text_classification.ipynb)
或[TensorFlow notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/text_classification-tf.ipynb)。

</Tip>

## 推断

太棒了，现在你已经微调了一个模型，可以用它进行推断了！

找到一些你想要运行推断的文本：

```
>>> text = "This was a masterpiece. Not completely faithful to the books, but enthralling from beginning to end. Might be my favorite of the three."
```

The simplest way to try out your finetuned model for inference is to use it in a [`pipeline`]. Instantiate a `pipeline` for sentiment analysis with your model, and pass your text to it:

```py
>>> from transformers import pipeline

>>> classifier = pipeline("sentiment-analysis", model="stevhliu/my_awesome_model")
>>> classifier(text)
[{'label': 'POSITIVE', 'score': 0.9994940757751465}]
```

You can also manually replicate the results of the `pipeline` if you'd like:

<frameworkcontent>
<pt>
Tokenize the text and return PyTorch tensors:

```py
>>> from transformers import AutoTokenizer

>>> tokenizer = AutoTokenizer.from_pretrained("stevhliu/my_awesome_model")
>>> inputs = tokenizer(text, return_tensors="pt")
```

Pass your inputs to the model and return the `logits`:

```py
>>> from transformers import AutoModelForSequenceClassification

>>> model = AutoModelForSequenceClassification.from_pretrained("stevhliu/my_awesome_model")
>>> with torch.no_grad():
...     logits = model(**inputs).logits
```

Get the class with the highest probability, and use the model's `id2label` mapping to convert it to a text label:

```py
>>> predicted_class_id = logits.argmax().item()
>>> model.config.id2label[predicted_class_id]
'POSITIVE'
```
</pt>
<tf>
Tokenize the text and return TensorFlow tensors:

```py
>>> from transformers import AutoTokenizer

>>> tokenizer = AutoTokenizer.from_pretrained("stevhliu/my_awesome_model")
>>> inputs = tokenizer(text, return_tensors="tf")
```

Pass your inputs to the model and return the `logits`:

```py
>>> from transformers import TFAutoModelForSequenceClassification

>>> model = TFAutoModelForSequenceClassification.from_pretrained("stevhliu/my_awesome_model")
>>> logits = model(**inputs).logits
```

Get the class with the highest probability, and use the model's `id2label` mapping to convert it to a text label:

```py
>>> predicted_class_id = int(tf.math.argmax(logits, axis=-1)[0])
>>> model.config.id2label[predicted_class_id]
'POSITIVE'
```
</tf>
</frameworkcontent>
```